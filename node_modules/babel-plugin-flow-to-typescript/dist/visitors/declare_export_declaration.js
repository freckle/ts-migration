"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const convert_flow_type_1 = require("../converters/convert_flow_type");
const convert_declare_variable_1 = require("../converters/convert_declare_variable");
const convert_declare_function_1 = require("../converters/convert_declare_function");
const convert_declare_type_alias_1 = require("../converters/convert_declare_type_alias");
const convert_declare_class_1 = require("../converters/convert_declare_class");
const replaceWith_1 = require("../utils/replaceWith");
const convert_interface_declaration_1 = require("../converters/convert_interface_declaration");
function DeclareExportDeclaration(path) {
    const node = path.node;
    let replacement;
    if (node.default) {
        if (!node.declaration) {
            throw path.buildCodeFrameError('todo: declaration is missing');
        }
        if (types_1.isDeclareFunction(node.declaration)) {
            replacement = types_1.exportDefaultDeclaration(convert_declare_function_1.convertDeclareFunction(node.declaration));
            replaceWith_1.replaceWith(path, replacement);
        }
        else if (types_1.isDeclareClass(node.declaration)) {
            replacement = types_1.exportDefaultDeclaration(convert_declare_class_1.convertDeclareClass(node.declaration));
            replaceWith_1.replaceWith(path, replacement);
        }
        else {
            if (!types_1.isFlowType(node.declaration)) {
                throw path.buildCodeFrameError('not implemented');
            }
            const declaration = convert_flow_type_1.convertFlowType(node.declaration);
            const aliasId = types_1.identifier('__default');
            path.replaceWithMultiple([
                types_1.variableDeclaration('const', [
                    types_1.variableDeclarator(Object.assign(Object.assign({}, aliasId), { typeAnnotation: types_1.tsTypeAnnotation(declaration) })),
                ]),
                types_1.exportDefaultDeclaration(aliasId),
            ]);
        }
    }
    else {
        let declaration = null;
        if (types_1.isDeclareVariable(node.declaration)) {
            declaration = convert_declare_variable_1.convertDeclareVariable(node.declaration);
        }
        else if (types_1.isDeclareFunction(node.declaration)) {
            declaration = convert_declare_function_1.convertDeclareFunction(node.declaration);
        }
        else if (types_1.isTypeAlias(node.declaration)) {
            declaration = convert_declare_type_alias_1.convertDeclareTypeAlias(node.declaration);
        }
        else if (types_1.isDeclareClass(node.declaration)) {
            declaration = convert_declare_class_1.convertDeclareClass(node.declaration);
        }
        else if (types_1.isInterfaceDeclaration(node.declaration)) {
            declaration = convert_interface_declaration_1.convertInterfaceDeclaration(node.declaration);
        }
        else {
            throw path.buildCodeFrameError(`DeclareExportDeclaration not converted`);
        }
        replacement = types_1.exportNamedDeclaration(declaration, node.specifiers ? node.specifiers : [], node.source);
        replaceWith_1.replaceWith(path, replacement);
    }
}
exports.DeclareExportDeclaration = DeclareExportDeclaration;
//# sourceMappingURL=declare_export_declaration.js.map