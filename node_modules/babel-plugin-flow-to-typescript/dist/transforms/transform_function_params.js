"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const convert_flow_type_1 = require("../converters/convert_flow_type");
const replaceWith_1 = require("../utils/replaceWith");
function transformFunctionParams(params) {
    let hasRequiredAfter = false;
    for (let i = params.length - 1; i >= 0; i--) {
        const paramNode = params[i];
        if (paramNode.isPattern()) {
            if (paramNode.isAssignmentPattern() && types_1.isIdentifier(paramNode.node.left)) {
                // argument with default value can not be optional in typescript
                paramNode.node.left.optional = false;
            }
            if (!paramNode.isAssignmentPattern()) {
                hasRequiredAfter = true;
            }
        }
        if (paramNode.isIdentifier()) {
            const param = paramNode.node;
            if (param.typeAnnotation && types_1.isTypeAnnotation(param.typeAnnotation)) {
                if (types_1.isNullableTypeAnnotation(param.typeAnnotation.typeAnnotation)) {
                    param.optional = !hasRequiredAfter;
                    if (param.optional) {
                        let tsType = convert_flow_type_1.convertFlowType(param.typeAnnotation.typeAnnotation.typeAnnotation);
                        if (types_1.isTSFunctionType(tsType)) {
                            tsType = types_1.tsParenthesizedType(tsType);
                        }
                        const typeAnnotation = types_1.tsUnionType([tsType, types_1.tsNullKeyword()]);
                        replaceWith_1.replaceWith(paramNode.get('typeAnnotation'), types_1.tsTypeAnnotation(typeAnnotation));
                    }
                    else {
                        hasRequiredAfter = true;
                    }
                }
                else {
                    if (param.optional && hasRequiredAfter) {
                        param.optional = false;
                        let tsType = convert_flow_type_1.convertFlowType(param.typeAnnotation.typeAnnotation);
                        if (types_1.isTSFunctionType(tsType)) {
                            tsType = types_1.tsParenthesizedType(tsType);
                        }
                        const typeAnnotation = types_1.tsUnionType([tsType, types_1.tsUndefinedKeyword(), types_1.tsNullKeyword()]);
                        replaceWith_1.replaceWith(paramNode.get('typeAnnotation'), types_1.tsTypeAnnotation(typeAnnotation));
                    }
                    if (!param.optional) {
                        hasRequiredAfter = true;
                    }
                }
            }
        }
    }
}
exports.transformFunctionParams = transformFunctionParams;
//# sourceMappingURL=transform_function_params.js.map