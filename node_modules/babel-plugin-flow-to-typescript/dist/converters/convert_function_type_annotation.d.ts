import { FunctionTypeAnnotation } from '@babel/types';
export declare function convertFunctionTypeAnnotation(node: FunctionTypeAnnotation): {
    typeParams: {
        start: number | null;
        end: number | null;
        leadingComments: readonly import("@babel/types").Comment[] | null;
        innerComments: readonly import("@babel/types").Comment[] | null;
        trailingComments: readonly import("@babel/types").Comment[] | null;
        loc: import("@babel/types").SourceLocation | null;
        type: "TSTypeParameterDeclaration";
        params: import("@babel/types").TSTypeParameter[];
    } | undefined;
    parameters: ({
        start: number | null;
        end: number | null;
        leadingComments: readonly import("@babel/types").Comment[] | null;
        innerComments: readonly import("@babel/types").Comment[] | null;
        trailingComments: readonly import("@babel/types").Comment[] | null;
        loc: import("@babel/types").SourceLocation | null;
        type: "Identifier";
        name: string;
        decorators: import("@babel/types").Decorator[] | null;
        optional: boolean | null;
        typeAnnotation: import("@babel/types").TypeAnnotation | import("@babel/types").Noop | import("@babel/types").TSTypeAnnotation | null;
    } | {
        start: number | null;
        end: number | null;
        leadingComments: readonly import("@babel/types").Comment[] | null;
        innerComments: readonly import("@babel/types").Comment[] | null;
        trailingComments: readonly import("@babel/types").Comment[] | null;
        loc: import("@babel/types").SourceLocation | null;
        type: "RestElement";
        argument: import("@babel/types").LVal;
        decorators: import("@babel/types").Decorator[] | null;
        typeAnnotation: import("@babel/types").TypeAnnotation | import("@babel/types").Noop | import("@babel/types").TSTypeAnnotation | null;
    })[];
    returnType: import("@babel/types").TSTypeAnnotation | null;
};
