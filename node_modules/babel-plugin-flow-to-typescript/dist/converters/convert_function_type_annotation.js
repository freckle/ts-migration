"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const util_1 = require("../util");
const convert_flow_type_1 = require("./convert_flow_type");
const convert_type_parameter_declaration_1 = require("./convert_type_parameter_declaration");
const baseNodeProps_1 = require("../utils/baseNodeProps");
function convertFunctionTypeAnnotation(node) {
    let typeParams = undefined;
    if (node.typeParameters !== null) {
        typeParams = Object.assign(Object.assign({}, convert_type_parameter_declaration_1.convertTypeParameterDeclaration(node.typeParameters)), baseNodeProps_1.baseNodeProps(node.typeParameters));
    }
    const parameters = [];
    let returnType = null;
    // Params
    if (node.params) {
        const paramNames = node.params
            .map(_ => _.name)
            .filter(_ => _ !== null)
            .map(_ => _.name);
        let hasRequiredAfter = false;
        for (let i = node.params.length - 1; i >= 0; i--) {
            const param = node.params[i];
            let name = param.name && param.name.name;
            // Generate param name? (Required in TS, optional in Flow)
            if (name == null) {
                name = util_1.generateFreeIdentifier(paramNames);
                paramNames.push(name);
            }
            const id = types_1.identifier(name);
            id.optional = param.optional;
            if (param.typeAnnotation) {
                let typeAnnotation;
                if (types_1.isNullableTypeAnnotation(param.typeAnnotation)) {
                    if (!hasRequiredAfter) {
                        id.optional = true;
                    }
                    if (id.optional) {
                        let tsType = convert_flow_type_1.convertFlowType(param.typeAnnotation.typeAnnotation);
                        if (types_1.isTSFunctionType(tsType)) {
                            tsType = types_1.tsParenthesizedType(tsType);
                        }
                        typeAnnotation = types_1.tsUnionType([tsType, types_1.tsNullKeyword()]);
                    }
                    else {
                        typeAnnotation = convert_flow_type_1.convertFlowType(param.typeAnnotation);
                        hasRequiredAfter = true;
                    }
                }
                else {
                    typeAnnotation = convert_flow_type_1.convertFlowType(param.typeAnnotation);
                    hasRequiredAfter = true;
                }
                id.typeAnnotation = Object.assign(Object.assign({}, types_1.tsTypeAnnotation(typeAnnotation)), baseNodeProps_1.baseNodeProps(param.typeAnnotation));
            }
            parameters.unshift(Object.assign(Object.assign({}, id), baseNodeProps_1.baseNodeProps(param)));
        }
    }
    // rest parameters
    if (node.rest) {
        if (node.rest.name) {
            const id = types_1.restElement(node.rest.name);
            id.typeAnnotation = types_1.tsTypeAnnotation(convert_flow_type_1.convertFlowType(node.rest.typeAnnotation));
            parameters.push(Object.assign(Object.assign({}, id), baseNodeProps_1.baseNodeProps(node.rest)));
        }
    }
    // Return type
    if (node.returnType) {
        returnType = types_1.tsTypeAnnotation(Object.assign(Object.assign({}, convert_flow_type_1.convertFlowType(node.returnType)), baseNodeProps_1.baseNodeProps(node.returnType)));
    }
    return { typeParams, parameters, returnType };
}
exports.convertFunctionTypeAnnotation = convertFunctionTypeAnnotation;
//# sourceMappingURL=convert_function_type_annotation.js.map