"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const util_1 = require("../util");
const convert_flow_identifier_1 = require("./convert_flow_identifier");
const convert_function_type_annotation_1 = require("./convert_function_type_annotation");
const convert_object_type_call_property_1 = require("./convert_object_type_call_property");
const convert_object_type_indexer_1 = require("./convert_object_type_indexer");
const convert_object_type_internal_slot_1 = require("./convert_object_type_internal_slot");
const baseNodeProps_1 = require("../utils/baseNodeProps");
const convert_object_type_property_1 = require("./convert_object_type_property");
function convertFlowType(node) {
    if (types_1.isAnyTypeAnnotation(node)) {
        return types_1.tsAnyKeyword();
    }
    if (types_1.isArrayTypeAnnotation(node)) {
        return types_1.tsArrayType(Object.assign(Object.assign({}, convertFlowType(node.elementType)), baseNodeProps_1.baseNodeProps(node.elementType)));
    }
    if (types_1.isBooleanTypeAnnotation(node)) {
        return types_1.tsBooleanKeyword();
    }
    if (types_1.isBooleanLiteralTypeAnnotation(node)) {
        return types_1.tsLiteralType(types_1.booleanLiteral(node.value));
    }
    if (types_1.isEmptyTypeAnnotation(node)) {
        return types_1.tsNeverKeyword();
    }
    if (types_1.isExistsTypeAnnotation(node)) {
        util_1.warnOnlyOnce('Existential type (*) in Flow is converted to "any" in TypeScript, and this conversion loses some type information.');
        return types_1.tsAnyKeyword();
    }
    if (types_1.isGenericTypeAnnotation(node)) {
        const typeParameters = node.typeParameters;
        let tsTypeParameters = null;
        if (typeParameters) {
            const tsParams = typeParameters.params.map(p => (Object.assign(Object.assign({}, convertFlowType(p)), baseNodeProps_1.baseNodeProps(p))));
            tsTypeParameters = types_1.tsTypeParameterInstantiation(tsParams);
        }
        const id = node.id;
        if (types_1.isIdentifier(id) && id.name === '$Keys') {
            // $Keys -> keyof
            const ret = types_1.tsTypeOperator(tsTypeParameters.params[0]);
            ret.operator = 'keyof';
            return ret;
        }
        else if (types_1.isIdentifier(id) && id.name === '$Values') {
            // $Values<X> -> X[keyof X]
            const tsType = tsTypeParameters.params[0];
            const tsKey = types_1.tsTypeOperator(tsType);
            tsKey.operator = 'keyof';
            return types_1.tsIndexedAccessType(tsType, tsKey);
        }
        else if (types_1.isIdentifier(id) && id.name === '$ReadOnly') {
            // $ReadOnly<X> -> Readonly<X>
            return types_1.tsTypeReference(types_1.identifier('Readonly'), tsTypeParameters);
        }
        else if (types_1.isIdentifier(id) && id.name === '$ReadOnlyArray') {
            // $ReadOnlyArray<X> -> ReadonlyArray<X>
            return types_1.tsTypeReference(types_1.identifier('ReadonlyArray'), tsTypeParameters);
        }
        else if (types_1.isIdentifier(id) && id.name === '$Exact') {
            util_1.warnOnlyOnce("Exact object type annotation in Flow is ignored. In TypeScript, it's always regarded as exact type");
            return tsTypeParameters.params[0];
        }
        else if (types_1.isIdentifier(id) && id.name === '$Diff') {
            // type $Diff<X, Y> = Omit<X, keyof y>;
            const [tsX, tsY] = tsTypeParameters.params;
            let tsKeyofY = types_1.tsTypeOperator(tsY);
            tsKeyofY.operator = 'keyof';
            if (types_1.isTSTypeLiteral(tsY)) {
                const keys = [];
                let doable = true;
                tsY.members.forEach(m => {
                    if (types_1.isTSPropertySignature(m) || types_1.isTSMethodSignature(m)) {
                        if (types_1.isIdentifier(m.key)) {
                            keys.push(m.key.name);
                        }
                        else if (types_1.isStringLiteral(m.key)) {
                            keys.push(m.key.value);
                        }
                        else {
                            doable = false;
                        }
                    }
                    else if (types_1.isTSIndexSignature(m)) {
                        doable = false;
                    }
                });
                if (doable) {
                    tsKeyofY = types_1.tsUnionType(keys.map(p => types_1.tsLiteralType(types_1.stringLiteral(p))));
                }
            }
            return types_1.tsTypeReference(types_1.identifier('Omit'), types_1.tsTypeParameterInstantiation([tsX, tsKeyofY]));
        }
        else if (types_1.isIdentifier(id) && id.name === '$PropertyType') {
            // $PropertyType<T, k> -> T[k]
            // TODO: $PropertyType<T, k> -> k extends string ? T[k] : never
            const [tsT, tsK] = tsTypeParameters.params;
            return types_1.tsIndexedAccessType(tsT, tsK);
        }
        else if (types_1.isIdentifier(id) && id.name === '$ElementType') {
            // $ElementType<T, k> -> T[k]
            const [tsT, tsK] = tsTypeParameters.params;
            return types_1.tsIndexedAccessType(tsT, tsK);
        }
        else if (types_1.isIdentifier(id) && id.name === '$Shape') {
            // $Shape<T> -> Partial<T>
            return types_1.tsTypeReference(types_1.identifier('Partial'), tsTypeParameters);
        }
        else if (types_1.isIdentifier(id) && id.name === 'Class') {
            // skip because result might be incorrect syntax for typescript in some cases
            // Class<T> helper to be added instead
            return types_1.tsTypeReference(convert_flow_identifier_1.convertFlowIdentifier(id), tsTypeParameters);
            // Class<T> -> typeof T
            //
            // const tsType = tsTypeParameters!.params[0];
            // const tsTypeofT = tsTypeOperator(tsType);
            // tsTypeofT.operator = 'typeof';
            // return tsTypeofT;
            //
            // This is correct for case when T is variable, but when it is type this is no longer valid:
            //
            // type A = Class<{}>
            // type B = Class<Component<*,*>>
        }
        else if (types_1.isIdentifier(id) && id.name === '$FlowFixMe') {
            return types_1.tsTypeReference(types_1.identifier('any'), tsTypeParameters);
        }
        else if (types_1.isIdentifier(id) && id.name === 'Object') {
            return types_1.tsObjectKeyword();
        }
        else if (types_1.isQualifiedTypeIdentifier(id) || types_1.isIdentifier(id)) {
            return types_1.tsTypeReference(convert_flow_identifier_1.convertFlowIdentifier(id), tsTypeParameters && tsTypeParameters.params.length ? tsTypeParameters : null);
        }
        // for other utility types, helpers are added at top of file in Program visitor
    }
    if (types_1.isIntersectionTypeAnnotation(node)) {
        const flowTypes = node.types;
        return types_1.tsIntersectionType(flowTypes.map(v => {
            let tsType = convertFlowType(v);
            if (types_1.isTSFunctionType(tsType)) {
                tsType = types_1.tsParenthesizedType(tsType);
            }
            return Object.assign(Object.assign({}, tsType), baseNodeProps_1.baseNodeProps(v));
        }));
    }
    if (types_1.isMixedTypeAnnotation(node)) {
        return types_1.tsUnknownKeyword();
    }
    if (types_1.isNullableTypeAnnotation(node)) {
        let tsType = convertFlowType(node.typeAnnotation);
        if (types_1.isTSFunctionType(tsType)) {
            tsType = types_1.tsParenthesizedType(tsType);
        }
        // f(): ?T {} -> f(): T | null | undefined {}
        // var x: X<?T> -> var x: X<T | null | undefined>
        // var x:?T -> var x:T | null | undefined
        return types_1.tsUnionType([tsType, types_1.tsUndefinedKeyword(), types_1.tsNullKeyword()]);
    }
    if (types_1.isNullLiteralTypeAnnotation(node)) {
        return types_1.tsNullKeyword();
    }
    if (types_1.isNumberLiteralTypeAnnotation(node)) {
        return types_1.tsLiteralType(types_1.numericLiteral(node.value));
    }
    if (types_1.isNumberTypeAnnotation(node)) {
        return types_1.tsNumberKeyword();
    }
    if (types_1.isObjectTypeAnnotation(node)) {
        const members = [];
        const spreads = [];
        if (node.exact) {
            util_1.warnOnlyOnce("Exact object type annotation in Flow is ignored. In TypeScript, it's always regarded as exact type");
            node.exact = false;
        }
        if (node.properties && node.properties.length > 0) {
            for (const property of node.properties) {
                if (types_1.isObjectTypeProperty(property)) {
                    members.push(Object.assign(Object.assign({}, convert_object_type_property_1.convertObjectTypeProperty(property)), baseNodeProps_1.baseNodeProps(property)));
                }
                if (types_1.isObjectTypeSpreadProperty(property)) {
                    // {p1:T, ...U} -> {p1:T} & U
                    spreads.push(convertFlowType(property.argument));
                }
            }
        }
        if (node.indexers && node.indexers.length > 0) {
            members.push(...node.indexers.map(convert_object_type_indexer_1.convertObjectTypeIndexer));
        }
        if (node.callProperties) {
            members.push(...node.callProperties.map(convert_object_type_call_property_1.convertObjectTypeCallProperty));
        }
        if (node.internalSlots) {
            members.push(...node.internalSlots.map(convert_object_type_internal_slot_1.convertObjectTypeInternalSlot));
        }
        // TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSMethodSignature ;
        let ret = types_1.tsTypeLiteral(members);
        if (spreads.length > 0) {
            spreads.unshift(ret);
            ret = types_1.tsIntersectionType(spreads);
        }
        return ret;
    }
    if (types_1.isStringLiteralTypeAnnotation(node)) {
        return types_1.tsLiteralType(types_1.stringLiteral(node.value));
    }
    if (types_1.isStringTypeAnnotation(node)) {
        return types_1.tsStringKeyword();
    }
    if (types_1.isThisTypeAnnotation(node)) {
        return types_1.tsThisType();
    }
    if (types_1.isTypeofTypeAnnotation(node)) {
        const typeOp = types_1.tsTypeOperator(convertFlowType(node.argument));
        typeOp.operator = 'typeof';
        return typeOp;
    }
    if (types_1.isUnionTypeAnnotation(node)) {
        const flowTypes = node.types;
        return types_1.tsUnionType(flowTypes.map(v => {
            let tsType = convertFlowType(v);
            if (types_1.isTSFunctionType(tsType)) {
                tsType = types_1.tsParenthesizedType(tsType);
            }
            return Object.assign(Object.assign({}, tsType), baseNodeProps_1.baseNodeProps(v));
        }));
    }
    if (types_1.isVoidTypeAnnotation(node)) {
        return types_1.tsVoidKeyword();
    }
    if (types_1.isFunctionTypeAnnotation(node)) {
        const { typeParams, parameters, returnType } = convert_function_type_annotation_1.convertFunctionTypeAnnotation(node);
        return types_1.tsFunctionType(typeParams, parameters, returnType);
    }
    if (types_1.isTupleTypeAnnotation(node)) {
        const flowTypes = node.types;
        return types_1.tsTupleType(flowTypes.map(convertFlowType));
    }
    throw new util_1.UnsupportedError(`FlowType(type=${node.type})`);
}
exports.convertFlowType = convertFlowType;
//# sourceMappingURL=convert_flow_type.js.map