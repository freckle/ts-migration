"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const convert_flow_type_1 = require("./convert_flow_type");
const baseNodeProps_1 = require("../utils/baseNodeProps");
const convert_object_type_indexer_1 = require("./convert_object_type_indexer");
const util_1 = require("../util");
const convert_interface_declaration_1 = require("./convert_interface_declaration");
const convert_type_parameter_declaration_1 = require("./convert_type_parameter_declaration");
const get_property_key_1 = require("./get_property_key");
function convertDeclareClass(node) {
    const bodyElements = [];
    for (const property of node.body.properties) {
        if (types_1.isObjectTypeSpreadProperty(property)) {
            throw new Error('ObjectTypeSpreadProperty is unexpected in DeclareClass');
        }
        let convertedProperty = convert_flow_type_1.convertFlowType(property.value);
        if (types_1.isTSFunctionType(convertedProperty)) {
            convertedProperty = types_1.tsParenthesizedType(convertedProperty);
        }
        const { key, isComputed } = get_property_key_1.getPropertyKey(property);
        if (property.method) {
            if (!types_1.isTSParenthesizedType(convertedProperty) ||
                !types_1.isTSFunctionType(convertedProperty.typeAnnotation)) {
                throw new Error('incorrect method');
            }
            const converted = types_1.tsDeclareMethod(null, property.key, convertedProperty.typeAnnotation.typeParameters, convertedProperty.typeAnnotation.parameters, convertedProperty.typeAnnotation.typeAnnotation);
            // todo: fix bug in tsDeclareMethod builder to accept member expression
            converted.key = key;
            converted.static = !!property.static;
            // @ts-ignore
            converted.kind = property.kind;
            converted.computed = isComputed;
            bodyElements.push(converted);
        }
        else if (property.kind === 'init') {
            const converted = types_1.classProperty(key, null, types_1.tsTypeAnnotation(convertedProperty));
            converted.static = !!property.static;
            converted.readonly = property.variance && property.variance.kind === 'plus';
            converted.computed = isComputed;
            bodyElements.push(Object.assign(Object.assign({}, converted), baseNodeProps_1.baseNodeProps(property)));
        }
    }
    // todo:
    // if (node.body.callProperties) {
    //   bodyElements.push(...node.body.callProperties.map(convertObjectTypeCallProperty));
    // }
    if (node.body.indexers) {
        // tslint:disable-next-line:prettier
        bodyElements.push(...node.body.indexers.map(i => (Object.assign(Object.assign({}, convert_object_type_indexer_1.convertObjectTypeIndexer(i)), baseNodeProps_1.baseNodeProps(i)))));
    }
    // todo:
    // if (node.body.internalSlots) {
    //   bodyElements.push(...node.body.internalSlots.map(convertObjectTypeInternalSlot));
    // }
    let superClass = null;
    let superTypeParameters = null;
    if (node.extends && node.extends.length) {
        if (node.extends.length > 1) {
            util_1.warnOnlyOnce('declare-class-many-parents', 'Declare Class definitions in TS can only have one super class. Dropping extras.');
        }
        const firstExtend = convert_interface_declaration_1.convertInterfaceExtends(node.extends[0]);
        if (types_1.isIdentifier(firstExtend.expression)) {
            superClass = Object.assign(Object.assign({}, firstExtend.expression), baseNodeProps_1.baseNodeProps(node.extends[0].id));
            if (firstExtend.typeParameters && node.extends[0].typeParameters) {
                superTypeParameters = Object.assign(Object.assign({}, firstExtend.typeParameters), baseNodeProps_1.baseNodeProps(node.extends[0].typeParameters));
            }
        }
        else {
            throw new Error('not implemented');
        }
    }
    let typeParameters = null;
    if (types_1.isTypeParameterDeclaration(node.typeParameters)) {
        typeParameters = Object.assign(Object.assign({}, convert_type_parameter_declaration_1.convertTypeParameterDeclaration(node.typeParameters)), baseNodeProps_1.baseNodeProps(node.typeParameters));
    }
    const body = Object.assign(Object.assign({}, types_1.classBody(bodyElements)), baseNodeProps_1.baseNodeProps(node.body));
    let _implements = null;
    if (node.implements && node.implements.length) {
        _implements = node.implements.map(i => (Object.assign(Object.assign({}, convert_interface_declaration_1.convertInterfaceExtends(i)), baseNodeProps_1.baseNodeProps(i))));
    }
    const decl = types_1.classDeclaration(node.id, superClass, body, []);
    decl.implements = _implements;
    decl.superTypeParameters = superTypeParameters;
    decl.typeParameters = typeParameters;
    return decl;
}
exports.convertDeclareClass = convertDeclareClass;
//# sourceMappingURL=convert_declare_class.js.map