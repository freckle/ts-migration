"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@babel/types");
const convert_flow_type_1 = require("./convert_flow_type");
const convert_type_parameter_declaration_1 = require("./convert_type_parameter_declaration");
const convert_object_type_property_1 = require("./convert_object_type_property");
const baseNodeProps_1 = require("../utils/baseNodeProps");
const convert_object_type_call_property_1 = require("./convert_object_type_call_property");
const convert_object_type_indexer_1 = require("./convert_object_type_indexer");
const convert_object_type_internal_slot_1 = require("./convert_object_type_internal_slot");
function convertInterfaceExtends(node) {
    const typeParameters = node.typeParameters;
    const typeParameterParams = typeParameters ? typeParameters.params : [];
    const parameters = types_1.tsTypeParameterInstantiation(typeParameterParams.map(item => (Object.assign(Object.assign({}, convert_flow_type_1.convertFlowType(item)), baseNodeProps_1.baseNodeProps(item)))));
    return types_1.tsExpressionWithTypeArguments(node.id, typeParameterParams.length ? parameters : null);
}
exports.convertInterfaceExtends = convertInterfaceExtends;
function convertInterfaceDeclaration(node) {
    let typeParameters = null;
    if (node.typeParameters) {
        typeParameters = Object.assign(Object.assign({}, convert_type_parameter_declaration_1.convertTypeParameterDeclaration(node.typeParameters)), baseNodeProps_1.baseNodeProps(node.typeParameters));
    }
    let extendsCombined = [];
    if (node.extends && node.implements) {
        if (node.extends.length &&
            node.implements.length &&
            node.extends[0].start &&
            node.implements[0].start &&
            node.extends[0].start < node.implements[0].start) {
            extendsCombined = [...node.extends, ...node.implements];
        }
        else {
            extendsCombined = [...node.implements, ...node.extends];
        }
    }
    else {
        if (node.extends) {
            extendsCombined = node.extends;
        }
        if (node.implements) {
            extendsCombined = node.implements;
        }
    }
    let _extends = undefined;
    if (extendsCombined.length > 0) {
        _extends = extendsCombined.map(v => (Object.assign(Object.assign({}, convertInterfaceExtends(v)), baseNodeProps_1.baseNodeProps(v))));
    }
    const bodyElements = [];
    for (const property of node.body.properties) {
        if (types_1.isObjectTypeProperty(property)) {
            bodyElements.push(Object.assign(Object.assign({}, convert_object_type_property_1.convertObjectTypeProperty(property)), baseNodeProps_1.baseNodeProps(property)));
        }
    }
    if (node.body.callProperties) {
        bodyElements.push(...node.body.callProperties.map(v => (Object.assign(Object.assign({}, convert_object_type_call_property_1.convertObjectTypeCallProperty(v)), baseNodeProps_1.baseNodeProps(v)))));
    }
    if (node.body.indexers) {
        bodyElements.push(...node.body.indexers.map(v => (Object.assign(Object.assign({}, convert_object_type_indexer_1.convertObjectTypeIndexer(v)), baseNodeProps_1.baseNodeProps(v)))));
    }
    if (node.body.internalSlots) {
        bodyElements.push(...node.body.internalSlots.map(v => (Object.assign(Object.assign({}, convert_object_type_internal_slot_1.convertObjectTypeInternalSlot(v)), baseNodeProps_1.baseNodeProps(v)))));
    }
    const body = Object.assign(Object.assign({}, types_1.tsInterfaceBody(bodyElements)), baseNodeProps_1.baseNodeProps(node.body));
    return types_1.tsInterfaceDeclaration(node.id, typeParameters, _extends, body);
}
exports.convertInterfaceDeclaration = convertInterfaceDeclaration;
//# sourceMappingURL=convert_interface_declaration.js.map